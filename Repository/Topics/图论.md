> 给定一棵树，每个点对 $(x, y)$ 表示一条线路，你可以从线路端点处上车，从该线路上任意一点下车，问从 1 号点到达所有点所需要换乘的最小次数。

[The 2023 ICPC Asia Regionals Online Contest (2) (pintia.cn)](https://pintia.cn/market/item/1705511462254264320)

[Ubuntu Pastebin](https://pastebin.ubuntu.com/p/QzgpjhRm8p/)

关键字：树。

考虑我们将 1 号点为端点的所有线路放入队列，每次从队列取出一个线路，对线路上的点的答案逐个更新，并将该线路上能上车的点所对应的线路放入队列，重复此操作。复杂度 $\mathcal O(nm)$。

注意我们这个操作类似于 bfs，于是后续答案一定不优于前面更新的答案，所以并不需要更新已经有答案的点。然后发现每次需要更新的线路一定最多存在一段后缀没有被更新答案，于是我们对于每个线路只更新它没更新答案的后缀，复杂度 $\mathcal O(n)$。

---

[K-Subdivision_“范式杯”2023牛客暑期多校训练营1 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/57355/K)

[代码查看 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/view-submission?submissionId=62838046)

关键字：树，构造。

首先 bfs 找到所有距离 $1$ 号点小于等于 $k$ 的所有点，建成一棵树，记点 $x$ 到 $1$ 号点的距离为 $D_x$。

对于在树上的边，如果在其上面加点，一定是在叶子节点的上面加点，因为这样在树上的点距离 $1$ 号点的距离影响最小。

然后考虑不在树上的边，其它的点到 $1$ 号点的距离不会因为在这条边上加点而变动，于是我们可以在这条边上尽可能的添加更多的点，而不会影响其它点到根节点的距离。

综上，对于 bfs 树，我们遍历树上所有点 $u$ 的所有出边，如果该边不在树上，该边贡献为 $k - D_u$ ，然后对于所有叶子节点 $u$ 的唯一在树上的边，其贡献为 $k - D_u$。

---

> 给定一棵树，你可以将任意度数为 $2$ 的点删除并将相邻的两个点连起来，或者付出 $1$ 点代价将一个点及与他相连的边删除，问删掉一整棵树最少的代价。

[The 2022 ICPC Asia Regionals Online Contest (I) (pintia.cn)](https://pintia.cn/market/item/1571156622976593920)

[Ubuntu Pastebin](https://pastebin.ubuntu.com/p/9cBZ2KJXT2/)

关键字：贪心。

如果场上有度数为 $2$ 的节点，我们就可以不花费代价将他删除，如果场上没有度数为 $2$ 的节点，我们花费 $1$ 的代价，任意删除一个叶子节点，重复此操作，会发现所有除了叶子节点以外的点都可以不花费代价删除，于是最小代价就是叶子节点数目。

---

> 一棵树，最初只有 $1$ 号点，每秒对于树上所有点按编号依次生成 $k$ 个子节点，求 $x$，$y$ 的 LCA。

[Ubuntu Pastebin](https://pastebin.ubuntu.com/p/2SP8qYp68S/)

关键字：强结论。

$m$ 轮后树有 $k^m$ 个节点，一个节点 $x$ 的父亲可以通过上一轮的数量推算出这一轮该节点是第几个生成的，从而算出父亲，因为树高是 $log$ 的，可以暴力爬父亲找 LCA。
