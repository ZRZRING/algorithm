对于 subtask 1，我们可以枚举最高点在哪里，然后暴力去判断当前状态需要加的区间，然后直接对序列进行相应的操作，重复此过程即可。对于一字型则与上述操作类似，不多赘述。

对于 subtask 4，我们可以对 subtask 1 的做法进行优化，我们发现每次加的次数仅取决于当前某两个相邻的点的差，于是枚举最高点，之后可以线性计算需要进行操作的次数。

对于 100 分做法，对原序列差分出来，把区间修改变成单点修改，即一个位置 +1 同时另一个位置 -1，当原序列修改的区间端点为全局端点时，可以等价于差分序列某一个位置 +1 或 -1，一字型对正负数分别求和取最大值，人字形枚举一个最高点，然后计算所有位置的贡献即可，最高点变换可以 $\mathcal{O}(1)$ 转移答案