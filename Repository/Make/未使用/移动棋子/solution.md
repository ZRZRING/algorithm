### 分析

独立的考虑每一个棋子，肯定是能走的时候一定会走，如果说这一步别的棋子走了导致自己不能走了，那就等一会走

贪心，这样一来答案就是每个棋子到 1 号点的距离加上等待的时间，在所有棋子里取最大值

考虑如何计算每个棋子需要等待的时间，这个过程比较困难，如果我们用全局的角度考虑，可以得出一些结论

一个棋子肯定会在某个时刻进入一个连通块，连通块里的所有棋子会连续不断的进入 1 号点，并且连通块会在某些点进行合并，一个连通块的贡献为该连通块首次有棋子进入 1 号点的某个儿子的时刻，加上整个连通块的点的数量

这样的话可以考虑全局瓶颈，因为是能走就走，根据已经推出来的结论，如果我们钦定深度最深的棋子畅通无阻，那么全局的瓶颈肯定是深度最深的棋子所在的连通块

因为 1 号点的特殊性，我们取所有 1 号点的儿子为关键节点，答案是所有关键节点的贡献的最大值

而关键节点的贡献就是，每个节点子树内深度最深的棋子到该关键点的距离加上该棋子所带领的连通块点的数量

由已推出的结论可得这样是正确的，那么这个连通块的点的数量怎么计算呢

首先深度最深的棋子是畅通无阻的，也就是说我们只有该点深度的时间去把别的棋子移到 1 号点使得它不会堵住深度最深的那个点

要考虑整个过程有那些点不属于深度最深的棋子的连通块貌似有点困难，但是时间戳和点是一一对应的，所以我们考虑哪些时间戳会有点出去就好了

于是 $\mathcal{O}(n)$ 的复杂度通过此题

### 思路 1

贪心，能移动一定会移动

考虑对于 1 号点的每个儿子为根的子树进行考虑，显然次数的瓶颈在于深度最深的点，那么先让一个深度最深的点一直移动直到进入 1 号点，之后每个时刻都会有点进入 1 号点了

于是计算一下最深的深度 $d$，子树内点的数量 $c$，然后让某一个深度最深棋子畅通无阻得移动到 1 号点，计算这段时间内有棋子出去的时间戳数量，记为 $a$，一棵子树的贡献就是 $d + c - a$

然后对 1 号点的所有子树贡献取一个 $\max$ 即可，std 使用的是该思路

### 思路 2

记深度 $\geq i$ 的棋子个数为 $cnt_i$，深度 $i$ 的贡献为 $cnt_i + i - 1$，对所有深度求最大值即可

依旧是对 1 号点每个子树单独跑一边取最大值

### 题外话 - 动态维护

我们现在换个情景，我们设棋子一旦开始走就不能停，且1号点只有一个儿子，并且支持修改，支持加入一个棋子，删除一个棋子

为了动态维护，这个题的做法基于上述思路就产生了不一样的解释方法

考虑每个棋子所在节点的深度 $d_i$，每只棋子钦定一个 $\leq d_i$ 的到达时刻，并且没有两只棋子的到达时刻相等

记深度为 $i$ 的棋子个数为 $cnt_i$，从小到大枚举 $i$，先往栈里加入 $cnt_i$ 个棋子，如果栈非空就从栈中弹出一个棋子

可以考虑用线段树维护 $ans_i$ 表示考虑时刻 $i$ 后还剩多少棋子，线段树二分查找某个位置后第一次出现连续两个 $0$ 的位置和某个位置后第一个 $0$ 即可