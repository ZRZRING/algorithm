<!--more-->

学习平衡树首先要学习一下二叉查找树
 
二叉查找树顾名思义，就是维护一棵支持查找的二叉树，在序列问题上，我们一般构造一棵二叉树，使其中序遍历等于原序列，这样我们的序列操作就转换成一系列在树上的操作，从而得到序列的答案，二叉查找树单次操作复杂度期望$O(\log n)$，最坏$O(n)$

但由于题目中数据可构造，一棵二叉查找树的深度达到最坏，单次操作复杂度就会达到$O(n)$，这是不能接受的，而平衡树是一种优化二叉查找树的复杂度的算法

平衡树基本都可以用这个[模板](https://www.luogu.com.cn/problem/P3369)检验基本操作是否掌握

平衡树算法种类多种多样，常见的有红黑树、AVL、替罪羊树、Treap、Splay、Leafy、fhqtreap

~~qwaszx：来学Leafy吧~~

# 伸展树 Splay

伸展树，多用于序列操作中，基本操作是将一个节点转到根，支持的操作众多且复杂度稳定，缺点是不可以可持久化

以下内容部分摘自[OIwiki](https://oi-wiki.org/ds/splay/)

#### rotate

>旋转一个节点x到深度更小的位置

![Splay.png](https://i.loli.net/2019/12/11/ws2AjQtM9daC7vD.png)

这张图表示了对于一个节点，我们怎么旋转它，使这棵树的中序遍历不变，并使这个节点去深度更小的位置

我们设要旋转的节点为$x$，该节点的父亲为$y$，`son[y][0]`表示$y$的左儿子，`son[y][1]`表示$y$的右儿子，$kind$表示$x$是$y$的哪一个儿子，具体旋转过程看代码吧

```cpp
bool l_r(int x) {
    return x == son[fa[x]][1];
}
void rotate(int x, int &goal) {
    int y = fa[x], z = fa[y], kind = l_r(x);
    if (y == goal) goal = x; else son[z][l_r(y)] = x;
    son[y][kind] = son[x][kind ^ 1]; fa[son[x][kind ^ 1]] = y;
    son[x][kind ^ 1] = y; fa[y] = x; fa[x] = z;
    pushup(y); pushup(x);
}
```

#### Splay

>将一个节点x转到根

当我们想要将一个节点转到根的时候，我们每次把一个节点转到父节点的位置，然后让父节点下来做自己的子节点就可以了，具体见下面的旋转操作

有个问题，一条链按这个做法进行下去的话，岂不是还是一条链

所以我们不能单纯这么瞎转，如果从该节点的父节点的父节点到这个点是一条链的话，我们先转父节点再转这个节点，如果不是，那旋转两次这个节点，这样我们转完以后深度就可以大大减小了

```cpp
void splay(int x, int &goal) {
    for (int y = fa[x]; x != goal; y = fa[x]) {
        if (y != goal) rotate(l_r(x) == l_r(y) ? y : x, goal);
        rotate(x, goal);
    }
}
```

#### query

>查询树上中序遍历的第x个节点的编号

对于序列操作来说这个操作非常重要，思路就是我们把这个排名x不断和当前节点的左子树大小进行比较，决定去左子树还是右子树里寻找

```cpp
int query(int t) {
    int x = rt;
    while (1) {
        if (t <= siz[ls]) x = ls;
        else {
            t -= siz[ls] + cnt[x];
            if (t <= 0) return val[x]; x = rs;
        }
    }
}
```

#### get_rank

>对于值x，求在树的中序遍历的位置

和find互为逆操作，就是我们比较的时候和左儿子的值比较就好了，此外，这个还可辅助删除操作找到这个值下的点并把它转到根

```cpp
int get_rank(int t) {
    int res = 1, x = rt;
    while (1) {
        if (t < val[x]) x = ls;
        else {
            res += siz[ls];
            if (t == val[x]) {splay(x, rt); return res;}
            res += cnt[x]; x = rs;
        }
    }
    return res;
}
```

#### pre & suf

>找值x的前驱后继

这个操作在splay上可以说非常简短，先insert我们查询的值，这个值所在的节点被转到根，那么前驱就是左子树里最大的那个数，后继就是右子树里最小的那个数，然后delete掉就好了，根据二叉查找树的性质这非常好实现

代码提供的严格小于或大于的做法

```cpp
//主函数里insert一个值x
int pre() {
    int x = son[rt][0]; while (rs) x = rs; return x;
}
int suf() {
    int x = son[rt][1]; while (ls) x = ls; return x;
}
//主函数里delete一个值x
```

#### insert

>在某个位置插入一个值x

一般题目都是插在序列末尾，直接按着关键字检查走下去就好了，其实插在哪里都有办法实现，具体可以自行考虑一下，甚至你插入一个序列都可以做到

那么插入的思路就是你根据你的需要，从根节点开始，每走一步之前判断一下应该去左儿子还是右儿子，直到找到一个空位置或者一个含有x信息的节点计算贡献为止

```cpp
void ins(int t) {
    if (!rt) {
        rt = ++tot; cnt[rt] = siz[rt] = 1; val[rt] = t; return;
    }
    int x = rt, fat = 0;
    while (1) {
        if (val[x] == t) {
            cnt[x]++; siz[x]++; pushup(fa[x]); splay(x, rt); return;
        }
        fat = x; x = son[x][t > val[x]];
        if (!x) {
            x = ++tot; cnt[x] = siz[x] = 1; val[x] = t;
            son[fat][t > val[fat]] = x; fa[x] = fat;
            splay(x, rt); return;
        }
    }
}
```

#### delete

>删除一个节点/值

删除一个节点和值的变化其实不大，自己想一下就好

思路是先把要删的节点(或者存储你这个值的节点)，转到根，然后分类讨论一下：

没有儿子，那树里就只有这个点了，直接删除，并且标记树为空(root=0)

只有一个儿子，那这个儿子就是删掉这个节点以后的root

有两个儿子，那么让这个节点的前驱或者后继代替它就行

```cpp
void del(int x) {
    get_rank(x); x = rt;
    if (cnt[x] > 1) {cnt[x]--; siz[x]--; return;}
    if (ls && rs) {
        int y = pre(); splay(y, rt); son[y][1] = rs; fa[rs] = y; return;
    }
    if (ls) {rt = ls; fa[rt] = 0; return;}
    if (rs) {rt = rs; fa[rt] = 0; return;}
    rt = 0;
}
```

例题1：[文艺平衡树](https://www.luogu.com.cn/problem/P3391)，[题解](http://zrzring.cn/index.php/archives/85)

对序列支持区间求和和区间反转，基本操作

例题2：[【NOI2005】维护数列](https://www.luogu.com.cn/problem/P2042)，[代码](https://www.luogu.com.cn/paste/umn8fdld)

比上一个题多了个区间删除和区间插入，这样一来split就是基本操作了，split是将一段连续的区间拎出来，具体就是把$l-1$放到根，$r+1$放到根的右儿子上，于是根的左儿子的右子树就是这个区间了，和上一个题完全一致，我们在把这个思路放到区间删除和区间插入上即可

此外，本题卡空间，但有一个同时序列最多$5\times 10^5$的限制，我们可以回收节点，把删除过的节点重复利用，这一点可以用一个队列存储，然后把每次插入点的编号集合求出来建树就好了

90分的教训：pushdown的时候一定要判断有没有左/右儿子，因为我们$ans[0]$是有用的

# Treap

带旋treap，优点是常数小

#### 旋转

圈内通用叫法是zig,zag，但我容易记不住，于是决定换个叫法，左上位和右上位(lup,rup)，就是哪边的儿子往上走的意思，这样一来就不容易搞混了，当然觉得zig,zag更好理解的也可以

```cpp
void lup(int &x) {
    int y = ls; ls = son[y][1]; son[y][1] = x;
    siz[y] = siz[x]; pushup(x); x = y;
}
void rup(int &x) {
    int y = rs; rs = son[y][0]; son[y][0] = x;
    siz[y] = siz[x]; pushup(x); x = y;
}
```

#### ins

在到达插入的目的地之后给一个随机权值，并在递归的过程中一路和父亲的随机权值比较，通过旋转保证堆的性质

```cpp
void ins(int &x, int t) {
    if (!x) {
        x = ++tot; siz[x] = cnt[x] = 1; ls = rs = 0;
        val[x] = t; rnd[x] = rand(); return;
    }
    siz[x]++; if (val[x] == t) {cnt[x]++; pushup(x); return;}
    if (val[x] > t) {
        ins(ls, t); if (rnd[ls] < rnd[x]) lup(x);
    } else {
        ins(rs, t); if (rnd[rs] < rnd[x]) rup(x);
    }
}
```

#### del

找到删除的点之后给个标记递归回去，一路更新size

```cpp
bool del(int &x, int t) {
    if (!x) return 0;
    if (val[x] == t) {
        if (cnt[x] > 1) {siz[x]--; cnt[x]--; return 1;}
        if (!ls || !rs) {x = ls | rs; return 1;}
        rnd[ls] < rnd[rs] ? lup(x) : rup(x); return del(x, t);
    }
    if (del(son[x][val[x] < t] , t)) {siz[x]--; return 1;} else return 0;
}
```

其余操作就非常简单了，可以自己通过对二叉搜索树的理解自己写出来

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <queue>
#define inf 1e9
#define ls son[x][0]
#define rs son[x][1]
using namespace std;
void file() {
    freopen("read.in", "r", stdin);
    freopen("write.out", "w", stdout);
}
const int N = 1e6 + 10;
inline int read() {
    int sym = 0, res = 0; char ch = getchar();
    while (!isdigit(ch)) sym |= (ch == '-'), ch = getchar();
    while (isdigit(ch)) res = (res << 3) + (res << 1) + (ch ^ 48), ch = getchar();
    return sym ? -res : res;
}
int n, m, tot, rt;
int siz[N], cnt[N], val[N], rnd[N], son[N][2];
void pushup(int x) {siz[x] = siz[ls] + siz[rs] + cnt[x];}
void lup(int &x) {int y = ls; ls = son[y][1]; son[y][1] = x; siz[y] = siz[x]; pushup(x); x = y;}
void rup(int &x) {int y = rs; rs = son[y][0]; son[y][0] = x; siz[y] = siz[x]; pushup(x); x = y;}
void ins(int &x, int t) {
    if (!x) {
        x = ++tot; siz[x] = cnt[x] = 1; ls = rs = 0;
        val[x] = t; rnd[x] = rand(); return;
    }
    siz[x]++; if (val[x] == t) {cnt[x]++; pushup(x); return;}
    if (val[x] > t) {
        ins(ls, t); if (rnd[ls] < rnd[x]) lup(x);
    } else {
        ins(rs, t); if (rnd[rs] < rnd[x]) rup(x);
    }
}
bool del(int &x, int t) {
    if (!x) return 0;
    if (val[x] == t) {
        if (cnt[x] > 1) {siz[x]--; cnt[x]--; return 1;}
        if (!ls || !rs) {x = ls | rs; return 1;}
        rnd[ls] < rnd[rs] ? lup(x) : rup(x); return del(x, t);
    }
    if (del(son[x][val[x] < t] , t)) {siz[x]--; return 1;} else return 0;
}
int getrk(int t) {
    int x = rt, res = 1;
    while (x) {
        if (val[x] > t) x = ls;
        else { 
            res += siz[ls]; if (val[x] == t) return res;
            res += cnt[x]; x = rs;
        }
    }
    return res;
}
int query(int t) {
    int x = rt;
    while (x) {
        if (siz[ls] >= t) x = ls;
        else {
            t -= siz[ls] + cnt[x]; if (t <= 0) return val[x]; x = rs;
        }
    }
}
int pre(int t) {
    int x = rt, res = 0;
    while (x) {
        if (val[x] >= t) x = ls;
        else res = val[x], x = rs;
    }
    return res;
}
int suf(int t) {
    int x = rt, res = 0;
    while (x) {
        if (val[x] <= t) x = rs;
        else res = val[x], x = ls;
    }
    return res;
}
int main() {
    n = read();
    for (int i = 1; i <= n; i++) {
        int opt = read(), t = read();
        if (opt == 1) ins(rt, t);
        if (opt == 2) del(rt, t);
        if (opt == 3) printf("%d\n", getrk(t));
        if (opt == 4) printf("%d\n", query(t));
        if (opt == 5) printf("%d\n", pre(t));
        if (opt == 6) printf("%d\n", suf(t));
    }
    return 0;
}
```

# 替罪羊树

#### 重构

重点操作，定义一个$α$，每当一个节点的儿子的$size$大于自己的$size*α$，就把以这个节点为根的树重构，以保证二叉查找树的深度，从而保证复杂度，简单粗暴

```cpp

```