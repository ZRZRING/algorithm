<!--more-->

#### 树形dp

几乎所有树形dp的基本操作就是从根节点递归到叶子节点，然后由儿子的状态转移到父亲的状态，最终根节点记录全局的状态

一个板子题：[洛谷 P2014 [CTSC1997]选课](https://www.luogu.com.cn/problem/P2014)

每个儿子保证只有一个父亲，是一个树形结构，我们可以确定每一个点的最优解可以从它的儿子转移而来，并且不受自己的父亲的影响，没有后效性，所以我们可以用树形dp求解这个题

建图：对于每个节点$u$，我们把它连向所有需要它作为先修课的点

有一个常用的套路，为了避免森林，我们建立一个虚点0，连向没有先修课的点，这个虚点不会占用我学习课程的名额，于是全局是一个树结构了

设$f[u][i]$表示在以$u$为根的子树里选$i$门课能获得的最高学分，因为$u$是所有儿子的先修课，所以对于$i\not=0$我们一定要选择$u$这个点学习才可以，记$u$的子节点集合为$son(u)$，对于$\forall v\in son(u)$，我们已经递归求解过$v$这个点的信息了，然后我们对于它的所有儿子跑一个01背包就可以求出这个点的信息了，dp式子：

$$
f[u][i]=\max_{\forall v\in son(u),0\leq j\leq i}(f[v][i-j]+f[v][j])
$$


```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
using namespace std;
struct{
    int ver,pre,nxt;
}edge[1000100];
int cnt,head[1000100],n,m,dis[1000100],f[1001][1001];
inline int read(){
    int sym=0,res=0;char ch=0;
    while (ch<'0'||ch>'9')sym|=(ch=='-'),ch=getchar();
    while (ch>='0'&&ch<='9')res=(res<<3)+(res<<1)+(ch^48),ch=getchar();
    return sym?-res:res;
}
void file(){
    freopen("read.in","r",stdin);
    freopen("write.out","w",stdout);
}
void add(int u,int v){
    edge[++cnt].ver=v;
    edge[cnt].nxt=head[u];
    head[u]=cnt;
}
void dp(int u){
    f[u][0]=0;
    for (int i=head[u];i;i=edge[i].nxt){
        int v=edge[i].ver;dp(v);
        for (int j=m;j>=0;j--){
            for (int k=j;k>=0;k--){
                f[u][j]=max(f[u][j],f[u][j-k]+f[v][k]);
            }
        }
    }
    if (u!=0){
        for (int i=m;i>=1;i--){
            f[u][i]=f[u][i-1]+dis[u];
        }
    }
}
int main(){
    n=read(),m=read();
    for (int i=1;i<=n;i++){
        int x=read();dis[i]=read();
        add(x,i);
    }
    memset(f,207,sizeof(f));dp(0);
    printf("%d",f[0][q]);
    return 0;
}
```

树形dp还可以做什么

>树的重心，中心，直径

>二叉树

>最大独立集

其它的还有很多qwq，我不一一列举了

#### 单调队列优化dp

先看一道题：[洛谷 P1886 滑动窗口 /【模板】单调队列](https://www.luogu.com.cn/problem/P1886)

单调队列优化dp入门好题，我们知道队列支持从队头弹出队尾插入，而单调队列比队列多支持从队尾弹出操作，每当我们从队尾插入一个元素的时候，我们要保证这个队列是单调的，故我们要一次次把队尾弹出，直到我们把这个元素插入进去能保证单调为止

```cpp
//head到tail单调递增
void insert(int x){
    while (head<=tail&&q[tail]>x)tail--;
    q[++tail]=x;
}
```

对于滑动窗口这个题，我们弹出队头的时机是队头“过期了”，也就是我们和$q$同步记录一个$pos$，记录$q$内的元素在原数组的下标，当我们插入一个元素之后，判断队头有没有过期(对于每个题这个“过期”的定义不一样)

```cpp
//head到tail单调递增
void delete(int x){
	while (head<=tail&&p[head]<=i-k)head++;
}
```

上面我都说$head$到$tail$单调递增，也就是$q[head]$是队列里最小的元素，我们获取解的时候就直接访问队头就可以了


```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;
const int N=2000010;
int n,k,a[N],q[N],p[N];
inline int read(){
    int sym=0,res=0;char ch=0;
    while (ch<'0'||ch>'9')sym|=(ch=='-'),ch=getchar();
    while (ch>='0'&&ch<='9')res=(res<<3)+(res<<1)+(ch^48),ch=getchar();
    return sym?-res:res;
}
void file(){
    freopen("read.in","r",stdin);
    freopen("write.out","w",stdout);
}
int main(){
	n=read();k=read();
	for (int i=1;i<=n;i++)a[i]=read();
	int head=1,tail=0;
	for (int i=1;i<=n;i++){//最小 
		while (p[head]<=i-k&&head<=tail)head++;
		while (q[tail]>=a[i]&&head<=tail)tail--;
		q[++tail]=a[i];p[tail]=i;
		if (i>=k)printf("%d ",q[head]); 
	}printf("\n");
	head=1,tail=0;
	for (int i=1;i<=n;i++)q[i]=0,p[i]=0;
	for (int i=1;i<=n;i++){//最大 
		while (q[tail]<=a[i]&&head<=tail)tail--;
		while (p[head]<=i-k)head++;
		q[++tail]=a[i];p[tail]=i;
		if (i>=k)printf("%d ",q[head]); 
	}
    return 0;
}
```


啊上面那个不算是讲了一道题吧，我主要是想讲单调队列优化的思想，现在我们来做一道比较神仙的题目，2017年pj组的超纲题，个人感觉应该是tg难度

[洛谷 P3957 跳房子](https://www.luogu.com.cn/problem/P3957)

这个题我们很容易想到直接求解基本不可能，但是如果我们给定了一个$g$，我们就可以判断是否能拿到$k$个金币，而且，对于$g_2>g_1$，如果$g_1$能拿到$k$个金币，$g_2$就一定能拿到$k$个金币，因为$g$越大越灵活了

于是我们二分答案，对于一个$g$，我们考虑如何判断能否拿到$k$个金币，问题转化一下，应该是最多能拿到几个金币

考虑很容易想到的dp式：

$$
f[i]=\max_{d-g\leq pos[i]-pos[j]\leq d+g}(f[j])+val[i]
$$
$max$底下的数据范围可以写为$pos[i]-(d+g)\leq pos[j]\leq pos[i]-(d-g)$，自己化一下会发现是等价的，因为$pos$是单调递增的，随着$i$变大，$pos[i]$也在变大，所以$pos[j]$的范围整体右移，我们就可以用单调队列维护这之间的最大值了

代码实现相比上一个题困难一点，建议自己尝试一下

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <queue>
#define int long long
using namespace std;
const int N=2000010,inf=1<<30;
int n,d,k,pos[N],c[N],f[N],q[N];
inline int read(){
    int sym=0,res=0;char ch=0;
    while (ch<'0'||ch>'9')sym|=(ch=='-'),ch=getchar();
    while (ch>='0'&&ch<='9')res=(res<<3)+(res<<1)+(ch^48),ch=getchar();
    return sym?-res:res;
}
void file(){
    freopen("read.in","r",stdin);
    freopen("write.out","w",stdout);
}
bool check(int g){
    int L=max(1ll,d-g),R=d+g,head=1,tail=1,j=0,s=1;
    memset(f,0x8f,sizeof(f));f[0]=0;q[head]=0;//初始化为极小值
    while (pos[s]<L)s++;j=s;//找到第一个能过去的地方
    if (pos[s]>R)return false;//第一步就困家里了
    for(int i=s;i<=n;i++){
        int last=pos[i]-L;
        while(pos[j]<=last){//把所有能够一步走到pos[i]的状态加入队列
            while(head<=tail&&f[j]>f[q[tail]])tail--;
            q[++tail]=j;j++;
        }
        while(head<=tail&&pos[i]-pos[q[head]]>R)head++;//弹掉过期状态
        if (head>tail)continue;//队列为空
        f[i]=f[q[head]]+c[i];if(f[i]>=k)return true;
    }
    return false;
}
signed main(){
    n=read();d=read();k=read();int sum=0;
	for (int i=1;i<=n;i++){
		pos[i]=read();c[i]=read();sum+=(c[i]>0)*c[i];
	}
    if (sum<k){
        printf("-1");return 0;
    }
	int l=0,r=inf;
	while (l<r){
		int mid=l+r>>1;
		if (check(mid))r=mid;
        else l=mid+1;
	}printf("%d",r);
    return 0;
}
```

#### 动态DP

是的，这个dp比上面两个都要简单（确信）

考虑DP题中如果我们支持修改会怎么样，大多数时候直接会影响到很多的状态转移

但是我就给你1e5次修改呢？

很显然我们要优化，举个例子：[洛谷 P4719 【模板】"动态 DP"&动态树分治](https://www.luogu.com.cn/problem/P4719)

最大独立集就是基础了，很好求

但是有修改，一次修改就是一条链！

跳链想到什么，LCT！重链剖分！

你看多简单，你已经把这道题切掉了，嗯就是这样