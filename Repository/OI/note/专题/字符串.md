<!--more-->

# manacher

今天是2020年2月2日，是个非常稀有的回文日期日，~~非常适合写一遍2016年普及神题回文日期~~，那就纪念下我学会了manacher吧

明年的2021年12月2日我希望能学会PAM

[洛谷的manacher模板](https://www.luogu.com.cn/problem/P3805)

我们避免回文串的长度分类讨论，在每两个字符间加一个特殊字符，这样回文串的长度一定是奇数了

记以i为对称中心的回文串长度为p[i]

核心步骤在于对于前面已经找到的一个极长回文串，记录他的对称轴为mid，右端点为r，那我们后续mid + 1到r - 1的点直接就能链接到目前的这个mid的对称点，更新答案，如果到r之后仍没更新r和mid，那就重新寻找

由于对称性，设j为i关于mid的对称点，$p[i] \geq p[j]$

这样整个算法的复杂度就是线性的了

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;
void file() {
    freopen("read.in", "r", stdin);
    freopen("write.out", "w", stdout);
}
const int N = 1e8;
int n = 1, p[N], ans;
char a[N];
inline void read() {
    char ch = getchar();
    a[0] = '$', a[n] = '#';
    while (ch < 'a' || ch > 'z') ch = getchar();
    while (ch >= 'a' && ch <= 'z') a[++n] = ch, a[++n] = '#', ch = getchar();
}
int main() {
    read();
    for (int i = 1, r = 0, mid; i <= n; i++) {
        if (i <= r) p[i] = min(p[(mid << 1) - i], r - i + 1);
        while (a[i - p[i]] == a[i + p[i]]) ++p[i];
        if (p[i] + i > r) r = p[i] + i - 1, mid = i;
        ans = max(ans, p[i]);
    }
    printf("%d", ans - 1);
    return 0;
}
```

# 最小表示法

解决一个环形字符串从某处分割使得得到的字符串字典序最小的问题

# 扩展kmp

kmp是解决子串在母串中出现位置的，但是有的题要求子串对于母串的所有后缀的前缀匹配数量，我们仍然可以用kmp的思想解决

上一道[模板题](https://blog.csdn.net/Ronaldo7_ZYB/article/details/88782257)

题解写的用kmp做的，方法太巧妙了...