<!--more-->

作为一只brony，当然要打这个比赛了

吐槽一句，T2的那个箱子在S4E2出现，但是TS在S3结尾有了翅膀，这幅图根本没有翅膀好吧。。。

#### A​ Little Pony and Expected Maximum

>题目大意：求$m$面色子扔$n$次的期望最大值

可以得知，最大值在$[1,x]$的情况有$x^n$种，所以对于点数$i$，一共有$i^n-(i-1)^n$种情况最大值为$i$，每种情况贡献为$i$，所有情况的数量为$m^n$，于是答案为

$$ans=\frac{\sum_{i=1}^mi^n-(i-1)^n}{m^n}\times  i=\sum_{i=1}^m(\frac{i}{m})^n\times  i-(\frac{i-1}{m})^n\times  i$$


```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;
const int N=100010;
double n,m,ans;
inline int read(){
    int sym=0,res=0;char ch=0;
    while (ch<'0'||ch>'9')sym|=(ch=='-'),ch=getchar();
    while (ch>='0'&&ch<='9')res=(res<<3)+(res<<1)+(ch^48),ch=getchar();
    return sym?-res:res;
}
void file(){
    freopen("read.in","r",stdin);
    freopen("write.out","w",stdout);
}
int main(){
    m=read();n=read();ans=0;
    for (int i=1;i<=m;i++){
        ans+=i*(pow(i/m,n)-pow((i-1)/m,n));
    }
    printf("%.12lf",ans);
    return 0;
}
```

#### B​ Little Pony and Harmony Chest

>题目大意：找到一个长为$n$序列$b$，对于给定的序列$a$，使得$b$序列的数两两互质并最小化$\sum|a_i - b_i|$

从数据范围看出这是一道状压dp，考虑对于一个序列所有数都互质，当且仅当所有数的质因子互不相同，于是我们枚举每一个$b_i$的值，$p_i$表示$i$的质因数集合，$dp[i][j]$表示前$i$个数用$j$集合的质因子得到的最小的$\sum|a_i - b_i|$，容易得到转移方程

$$dp[i][j] = \min_{p[k]\subset j} |a_i - b_i| + dp[i - 1][j - p_k]$$


```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;
const int N=100010,inf=1e9+7,prime[16]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53};
int n,m,a[N],f[101][1<<16],p[N],ans[101][1<<16];
inline int read(){
    int sym=0,res=0;char ch=0;
    while (ch<'0'||ch>'9')sym|=(ch=='-'),ch=getchar();
    while (ch>='0'&&ch<='9')res=(res<<3)+(res<<1)+(ch^48),ch=getchar();
    return sym?-res:res;
}
void file(){
    freopen("read.in","r",stdin);
    freopen("write.out","w",stdout);
}
void write(int now,int x){
    if(!now)return;
    write(now-1,x^p[ans[now][x]]);
    printf("%d ",ans[now][x]);
}
int main(){
    n=read();
    for (int i=1;i<=n;i++){
        a[i]=read();
    }
    for (int i=1;i<=58;i++){
        for (int j=0;j<16;j++){
            if (i%prime[j]==0){
                p[i]^=(1<<j);
            }
        }
    }
    for (int i=1;i<=n;i++){
        for (int j=0;j<(1<<16);j++){
            f[i][j]=1e9;
            for (int k=1;k<=58;k++){
                if ((p[k]|j)!=j)continue;
                int now=abs(k-a[i])+f[i-1][j^p[k]];
                if (now<f[i][j])f[i][j]=now,ans[i][j]=k;
            }
        }
    }
    write(n,(1<<16)-1);
    return 0;
}
```

#### C Little Pony and Summer Sun Celebration

>题目大意：给一个$n$个点$m$条边的无向图$G$，求一个长度不超过$4n$的路径序列，使得对于给定一个$01$序列满足$a[i]=1$的点$i$经过奇数次，$a[i]=0$的点$i$经过偶数次

我们可以对于给定序列在图上dfs，经历一次就异或$1$，目标让序列变为全是$0$

路径序列长度不超过$4n$也就是经历的边数不超过$4n-1$

考虑对于每个点都要经历最少的次数来保证长度，很容易想到树形结构，对于每个节点，先异或$1$，然后进入所有儿子，而这个点有多少儿子就异或几次(从每个儿子回来再进入新的儿子，最后一个儿子回来再回到这个点的父亲)

但如果这个点异或到最后成了$1$的话，我们可以把让它回到父亲节点再下来再回去，这样父亲节点和这个节点就再异或$1$

最后根节点如果异或成$1$的话，我们就对答案序列$-3$，也就是我们不让根节点的最后一个儿子回到根节点了，因为根节点没有父节点，这样就少了一次异或$1$

可以得证，每条边最多经历$4$次，根节点到最后一个儿子的连边最多$2$次


```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;
const int N=200010;
struct EDGE{
    int ver,nxt;
}edge[N];
int n,m,head[N],cnt,vis[N],a[N],ans[N<<2],s;
inline int read(){
    int sym=0,res=0;char ch=0;
    while (ch<'0'||ch>'9')sym|=(ch=='-'),ch=getchar();
    while (ch>='0'&&ch<='9')res=(res<<3)+(res<<1)+(ch^48),ch=getchar();
    return sym?-res:res;
}
void file(){
    freopen("read.in","r",stdin);
    freopen("write.out","w",stdout);
}
void add(int u,int v){
    edge[++cnt].ver=v;
    edge[cnt].nxt=head[u];
    head[u]=cnt;
}
void dfs(int u,int fa){
    vis[u]=1;ans[++cnt]=u;a[u]^=1;
    for (int i=head[u];i;i=edge[i].nxt){
        int v=edge[i].ver;if (v==fa||vis[v])continue;
        dfs(v,u);ans[++cnt]=u;a[u]^=1;
    }if (a[u]){
        a[u]^=1;a[fa]^=1;ans[++cnt]=fa;ans[++cnt]=u;
    }
}
int main(){
    n=read();m=read();
    for (int i=1;i<=m;i++){
        int x=read(),y=read();add(x,y);add(y,x);
    }
    for (int i=1;i<=n;i++){
        a[i]=read();if (a[i])s=i;
    }cnt=0;
    if (s)dfs(s,-1);
    for (int i=1;i<=n;i++){
        if (!vis[i]&&a[i]){
            printf("-1");return 0;
        }
    }
    if (cnt>1&&ans[cnt-1]==-1)cnt-=3;
    printf("%d\n",cnt);
    for (int i=1;i<=cnt;i++){
        printf("%d ",ans[i]);
    }
    return 0;
}
```
