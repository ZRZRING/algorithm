<!--more-->

#### A [小W与伙伴招募](http://www.zhengruioi.com/contest/689/problem/1539)

> 你在商店买水晶，每个月商店刷新每种购买方式的次数，每个月有一个水晶的需求数量，求最小花费

考试时候想到的思路是分别对购买数量和需求求前缀和，最后每个位置取max，但是这个做法并不好优化

实际上有个更显然的思路，首先贪心买最便宜的，因为可以发现“为下周提前购买”和“在下周用上周的次数购买”是等效的，于是我们把每一周没用完的量保留到下一周，相当于对于上一周用完的残量再全局加上刷新商店带来的影响，这样就可以用线段树维护即可，询问就在线段树上二分

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <queue>
#define ls x << 1
#define rs x << 1 | 1
using namespace std;
void file() {
    freopen("std.in", "r", stdin);
    freopen("wa.out", "w", stdout);
}
const int N = 2e6 + 10, inf = 1e12;
inline int read() {
    bool sym = 0; int res = 0; char ch = getchar();
    while (!isdigit(ch)) sym |= (ch == '-'), ch = getchar();
    while (isdigit(ch)) res = (res << 3) + (res << 1) + (ch ^ 48), ch = getchar();
    return sym ? -res : res;
}
struct NODE {int cost, mx;} buy[N];
struct TREE {long long cnt, sum;} tr[N];
struct TAG {int add, cls;} tag[N];
int n, m, a[N];
long long sum[N], mx[N];
bool cmp(NODE a, NODE b) {return a.cost < b.cost;}
void pushup(int x) {
    tr[x] = (TREE){tr[ls].cnt + tr[rs].cnt, tr[ls].sum + tr[rs].sum};
}
void update(int x, int l, int r, int t) {
    tr[x] = (TREE){tr[x].cnt + t * (mx[r] - mx[l - 1]), tr[x].sum + t * (sum[r] - sum[l - 1])}; tag[x].add += t;
}
void clear(int x) {
    tag[x] = (TAG){0, 1}; tr[x] = (TREE){0, 0};
}
void pushdown(int x, int l, int r, int mid) {
    if (tag[x].cls) {
        clear(ls); clear(rs); tag[x].cls = 0;
    }
    if (tag[x].add) {
        update(ls, l, mid, tag[x].add); update(rs, mid + 1, r, tag[x].add); tag[x].add = 0;
    }
}
int query(int x, int l, int r, int t) {
    if (l == r) {
        tr[x].cnt -= t; tr[x].sum -= t * buy[l].cost;
        return t * buy[l].cost;
    }
    int mid = l + r >> 1; int res; pushdown(x, l, r, mid);
    if (t <= tr[ls].cnt) res = query(ls, l, mid, t);
    else res = tr[ls].sum + query(rs, mid + 1, r, t - tr[ls].cnt), clear(ls);
    pushup(x); return res;
}
signed main() {
    n = read(); m = read();
    for (int i = 1; i <= n; i++) a[i] = read();
    for (int i = 1; i <= m; i++) {
        buy[i].cost = read(); buy[i].mx = read();
    }
    sort(buy + 1, buy + m + 1, cmp);
    for (int i = 1; i <= m; i++) {
        if (buy[i].mx == -1) {m = i; mx[i] = mx[i - 1] + inf; break;}
        mx[i] = mx[i - 1] + buy[i].mx;
        sum[i] = sum[i - 1] + buy[i].mx * buy[i].cost;
    }
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        update(1, 1, m, 1); ans += query(1, 1, m, a[i]);
    }
    printf("%lld", ans);
    return 0;
}
```

#### B [小W与制胡串谜题](http://www.zhengruioi.com/contest/689/problem/1540)

> 输出给定n字符串拼凑出的字典序最小的字符串

很多年前的结论题，当时水平不太够所以没有理解很透彻，考试时候想到的是类似于SA的双关键字排序，但是并没有通过此题

排序，对于两个字符串a,b，若$a + b < b + a$，则a在前面，实际上这个式子很直观的表示了题意，所以正确性即为定义

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;
void file() {
    freopen("std.in", "r", stdin);
    freopen("wa.out", "w", stdout);
}
const int N = 1e6 + 10, inf = 1e9;
inline int read() {
    bool sym = 0; int res = 0; char ch = getchar();
    while (!isdigit(ch)) sym |= (ch == '-'), ch = getchar();
    while (isdigit(ch)) res = (res << 3) + (res << 1) + (ch ^ 48), ch = getchar();
    return sym ? -res : res;
}
struct NODE {
    int c[11], len;
} str[N], cpy[N];
int n, m, t1[30], t2[30];
char ch[11];
bool cmp(NODE a, NODE b) {
    for (int i = 1; i <= a.len; i++) t1[i] = a.c[i];
    for (int i = 1; i <= b.len; i++) t1[i + a.len] = b.c[i];
    for (int i = 1; i <= b.len; i++) t2[i] = b.c[i];
    for (int i = 1; i <= a.len; i++) t2[i + b.len] = a.c[i];
    for (int i = 1; i <= a.len + b.len; i++) {
        if (t1[i] != t2[i]) return t1[i] < t2[i];
    }
    return 0;
}
int main() {
    n = read();
    for (int i = 1; i <= n; i++) {
        scanf("%s", ch + 1); str[i].len = strlen(ch + 1);
        for (int j = 1; j <= str[i].len; j++) str[i].c[j] = ch[j] - 'a';
    }
    sort(str + 1, str + n + 1, cmp);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= str[i].len; j++) putchar(str[i].c[j] + 'a'); 
    }
    return 0;
}

```

#### C [小W与屠龙游戏](http://www.zhengruioi.com/contest/689/problem/1541)

> 你有n对石子堆，每对石子堆包含两个石子数为$s_i$的石子堆，且每对石子堆有一个权值$w_i$，现在你要选择一些对的石子堆使得下述游戏你必胜且使得选择的石子堆权值和最大
>
> 你为后手，你和boss轮流从至多两堆石子堆取任意数量的石子，不能取石子的一方判负

双方轮流从n堆石子中取x堆石子的任意数量，把每一堆的数量用二进制数表示，对应位相加并对x+1取模，每一位都为0即为先手必败状态

证明其正确性，考虑一个状态是必败状态当且仅当它的所有后继状态均为必胜状态，那么如果堆石子数满足上面的性质的话，应该是它的后继状态不会满足这个性质，才使命题正确

如果我们要对这x堆二进制下某一位集体-1的话，是不会在x+1取模下继续为0的，但是对于该位如果对某些堆-1并对某些堆+1的话，在更高的位是一定会被减的（NIM游戏只能“取”），也就是我们一定会存在一个极多-1的位且该位置不会出现加法的，而这个极多-1的位置不可能达到减去x+1，于是他的后继状态不可能有满足上述性质的状态

因为权值不能拆，所以每对石子堆是一个整体，上述引出本体的形式化解决方法

把所有石子堆的二进制看成向量，设每对石子堆选取$x_i \in \{0, 1, 2\}$堆石子，那么我们要求一组$x_i$满足以下条件即可
$$
\sum x_ia_i \not= 0
$$
线性基即可解决

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;
void file() {
    freopen("std.in", "r", stdin);
    freopen("wa.out", "w", stdout);
}
const int N = 1e6 + 10, inf = 1e9;
inline int read() {
    bool sym = 0; int res = 0; char ch = getchar();
    while (!isdigit(ch)) sym |= (ch == '-'), ch = getchar();
    while (isdigit(ch)) res = (res << 3) + (res << 1) + (ch ^ 48), ch = getchar();
    return sym ? -res : res;
}
inline long long lread() {
    bool sym = 0; long long res = 0; char ch = getchar();
    while (!isdigit(ch)) sym |= (ch == '-'), ch = getchar();
    while (isdigit(ch)) res = (res << 3) + (res << 1) + (ch ^ 48), ch = getchar();
    return sym ? -res : res;
}
struct NODE {
	long long p1, p2; int val;
} a[N];
NODE operator + (const NODE a, const NODE b) {
	long long ra = ~(a.p1 | a.p2), rb = ~(b.p1 | b.p2);
	return (NODE){a.p2 & b.p2 | a.p1 & rb | ra & b.p1, a.p1 & b.p1 | a.p2 & rb | ra & b.p2, a.val};
}
NODE operator - (const NODE a, const NODE b) {
	long long ra = ~(a.p1 | a.p2), rb = ~(b.p1 | b.p2);
	return (NODE){a.p2 & b.p1 | a.p1 & rb | ra & b.p2, a.p1 & b.p2 | a.p2 & rb | ra & b.p1, a.val};
}
int n, m;
long long ans;
void ins(NODE x) {
	for (int i = 60; i >= 0; i--) {
		if (x.p1 >> i & 1 | x.p2 >> i & 1) {
			if (!a[i].val) {
				ans += x.val; a[i] = x; return;
			}
			if (x.val > a[i].val) {
				ans += x.val - a[i].val; swap(a[i], x);
			}
			if ((x.p1 >> i & 1) & (a[i].p1 >> i & 1) | (x.p2 >> i & 1) & (a[i].p2 >> i & 1)) {
				x = x - a[i];
			} else {
				x = x + a[i];
			}
		}
	}
}
int main() {
    n = read();
    for (int i = 1; i <= n; i++) {
    	long long x = lread() ^ ans; int y = read();
    	ins((NODE){x, 0, y}); printf("%lld\n", ans);
    }
    return 0;
}
```

